---
title: Custom Stages
---

<!-- markdownlint-disable MD001 -->
<!-- markdownlint-disable MD029 -->

Wanting to create a custom Binding of Isaac stage is common. But the vanilla API does not have support for this. IsaacScript offers support for custom stages as part of its standard library. See the [getting started section](#getting-started) below.

Historically, people have used the [StageAPI](https://github.com/Meowlala/BOIStageAPI15) library to build custom stages, but using IsaacScript over StageAPI has several advantages. See the [motivation section](#motivation) below.

<br />

## Getting Started

First, make sure that you are familiar with IsaacScript and have built a practice mod or two. (See the [getting started](getting-started.md) guide.)

<br />

### Step 1 - Make Your Rooms

#### Create Rooms Using Basement Renovator

The most important part of a custom stage is custom rooms. So, you'll need to make some custom rooms for your custom stage.

Isaac comes with a room editor, but it no longer works with the Repentance DLC. Instead, you are supposed to build custom rooms using the community-built [Basement Renovator](https://github.com/Basement-Renovator/basement-renovator) program.

Using Basement Renovator to make rooms is outside of the scope of this tutorial, but it is pretty self-explanatory. You can read the GitHub readme for more details, if needed. Start a new file and start building some rooms.

#### Room Shapes and Door Slots

Most of your rooms will probably be standard 1x1 rooms with all 4 doors enabled. (A brown door represents that it is enabled, and a grey door represents that it is disabled.) However, you will also need to throw in some rooms of other shapes and door combinations. This is because when IsaacScript goes to deploy your custom rooms, it will match the vanilla rooms that are generated by the game.

For example, if you use Caves 1 as a base for your stage (more on that later), then the vanilla floor generation algorithm might randomly choose to generate this room:

<img src="/img/2x2-room.png" />

This is a 2x2 room with only doors on the left and right sides. When IsaacScript goes to replace this room, it will look through your rooms for a matching room - a 2x2 room with only doors on the left and right sides. If it doesn't find any, then it will give up, and leave the room as-is.

Thus, this means that if you want to have 100% custom rooms generated for your custom stage, you must have at least one room for every room shape + door configuration that is present on the base stage.

#### Saving Your Work

Once you have created your rooms, save them as an XML file in the following location:

```text
project/customStages/foo.xml
```

(This assumes that your mod is called "project" and your custom stage is called "foo".)

You don't need to include the corresponding STB file; all IsaacScript needs is the XML.

Note that you can actually save the XML file anywhere you like, as long as the path lines up with what you specify in the `tsconfig.json` file (more on that later). You probably should not put it in your "mod" directory though, since the XML file does not actually need to be uploaded to the Steam Workshop.

<br />

### Step 2 - Set Up `tsconfig.json`

After you have created your rooms and saved them as an XML file, the next step to tell IsaacScript about them. You define and configure your custom stages by adding information to the `tsconfig.json` file. (This is the TypeScript configuration file. It is already included with every IsaacScript mod, and lives in the root of your project.)

First, make sure that it has a "$schema" field at the top:

<!-- We specify the following code block as "ts" instead of "jsonc" because Docusaurus will mess up the syntax highlighting. -->

```ts
// We specify the schema to get auto-complete and validation.
"$schema": "https://raw.githubusercontent.com/IsaacScript/isaacscript/main/packages/isaacscript-cli/schemas/tsconfig-isaacscript-schema.json",
```

Second, make sure it has an "isaacscript" field at the bottom:

<!-- We specify the following code block as "ts" instead of "jsonc" because Docusaurus will mess up the syntax highlighting. -->

```ts
// IsaacScript settings
"isaacscript": {
  // A list of objects that represent the custom stages that are in your mod, if any. See:
  // https://isaacscript.github.io/main/custom-stages
  "customStages": [
    {
      "name": "Foo",
      "xmlPath": "./customStages/foo.xml",
      "roomVariantPrefix": 100,
    },
  ],
},
```

For the most basic stage, only the `name`, `xmlPath`, and `roomVariantPrefix` fields are required. But you will likely want to make additional customizations. There are many more optional fields that you can specify, like `baseStage` to specify what vanilla floor number should be used as a base for the stage. These optional fields are documented in the [`CustomStageTSConfig` interface](/isaacscript-common/other/interfaces/CustomStageTSConfig), so keep that in mind.

When you are first building and testing your custom stage, you can use a `roomVariantPrefix` of 100. But before you publish your mod to the Steam Workshop, you need to choose a unique number that won't conflict with any other mods. For more information, see the [Custom Stage Room Variant Prefixes](#custom-stage-room-variant-prefixes) section below.

<br />

### Step 3 - Add a Trapdoor to Go There

Once you have created your custom rooms and defined your custom stage in the `tsconfig.json` file, you need to add some code to your mod to generate a way for the player to get there. Obviously, the specifics of this will depend on how you want your custom stage to work. Maybe you want to add an additional trapdoor next to the Downpour trapdoor, or maybe you want to add an additional trapdoor inside of the Basement 1 shop.

As an example, let's imagine that we want a trapdoor to appear in the top-left hand corner of the starting room of the run. To create a custom trapdoor, we simply use the `spawnCustomTrapdoor` helper function.

```ts
const TOP_LEFT_CORNER_GRID_INDEX = 32;

const modVanilla = RegisterMod("MyMod", 1);
const features = [ISCFeature.CUSTOM_STAGES] as const;
const mod = upgradeMod(modVanilla, features);

mod.AddCallback(ModCallback.POST_GAME_STARTED, postGameStarted);

function postGameStarted(isContinued: boolean) {
  if (!isContinued) {
    mod.spawnCustomTrapdoor(TOP_LEFT_CORNER_GRID_INDEX, "Foo", 1);
  }
}
```

Here, "Foo" is the name of our custom stage, and 1 is the floor number. (For example, we could bypass Foo 1 and go directly to Foo 2 by specifying a 2 here.)

Now, by jumping into the trapdoor, the player will be taken to the custom stage. That's all we need to do!

If you want to code some custom way to travel to the custom stage that does not involve a trapdoor, you can do that too. See the following section.

<br />

### Going There With a Hotkey

During development, you might want to set up a custom hotkey to warp to your custom stage, which will speed up the testing process. You can do this with the `setCustomStage` helper function. If doing this, you must also call the `reloadRoom` function immediately afterwards to prevent being dragged into the `goto` console command room.

For example:

```ts
setHotkey(Keyboard.F1, () => {
  setCustomStage("Foo");
  reloadRoom();
});
```

<br />

### Bosses

If your custom stage does not have any custom bosses, then a vanilla boss will appear in the boss room corresponding to the base stage and stage type that you have specified. For example, if you chose Caves 1 as a base, then you would randomly get a boss of Chub, C.H.A.D., Gurdy, and so on.

On the other hand, if you specify the `bossPool` field in the `tsconfig.json` file, then the stage library will replace the vanilla boss room with a randomly selected one from the pool.

For example, imagine that your custom stage had two bosses, Alice and Bob. First, we would create them in the `entities2.xml` file, like we would for any other custom NPC:

```xml
<entity name="Alice" anm2path="custom-bosses/alice.anm2" baseHP="234" boss="1" champion="0" collisionDamage="1" collisionMass="20" collisionRadius="20" friction="1" gridCollision="walls" numGridCollisionPoints="12" portrait="111" shadowSize="30" stageHP="0" variant="0">
  <gibs amount="10" blood="1" bone="0" eye="1" gut="1" large="1" />
</entity>

<entity name="Bob" anm2path="custom-bosses/bob.anm2" baseHP="234" boss="1" champion="0" collisionDamage="1" collisionMass="20" collisionRadius="20" friction="1" gridCollision="walls" numGridCollisionPoints="12" portrait="111" shadowSize="30" stageHP="0" variant="0">
  <gibs amount="10" blood="1" bone="0" eye="1" gut="1" large="1" />
</entity>
```

(We should not specify the `bossID` field when declaring our entities here - that isn't needed.)

Second, we would create rooms for each boss in Basement Renovator. Make sure that each room has a type of a Boss Room, and an arbitrarily chosen sub-type corresponding to the boss. For example, we'll choose Alice to have a sub-type of 1, and Bob to have a sub-type of 2.

On the right-hand side of Basement Renovator, you can right click on the room in order to change its type and sub-type. The top-most field is the type, which defaults to "Normal Room". The bottom-most filed is the sub-type, which defaults to 0.

Third, we need to specify our bosses in the `bossPool` field of our `tsconfig.json` file:

```ts
"bossPool": [
  {
    "name": "Alice",
    "subType": 1,
    "weight": 3,
  },
  {
    "name": "Bob",
    "subType": 2,
    "weight": 1,
  },
],
```

Here, we map the name of the boss to the arbitrarily chosen sub-type. By specifying a sub-type of 1 for Alice, IsaacScript will automatically choose a random boss room matching that sub-type.

We also specify what the weight should be for each boss. In this case, we specified a weight of 3 for Alice, meaning that it will be three times as likely for Alice to appear than Bob.

Now, we can test the bosses in-game, and everything should work as expected.

Note that it is possible to have vanilla bosses in the boss pool, if needed. Thus, we could have a boss pool with a mix of custom bosses and vanilla bosses, or a boss pool of only vanilla bosses. To add a vanilla boss, just use the name that matches the real name of the entity, and use the sub-type corresponding to the [`BossID`](/isaac-typescript-definitions/enums/BossID/) enum. (And make sure that you create the corresponding rooms for the sub-type in your XML file.)

<br />

## Motivation

[StageAPI](https://github.com/Meowlala/BOIStageAPI15) is a fantastic library created by [DeadInfinity](https://steamcommunity.com/profiles/76561198172774482/myworkshopfiles/?appid=250900) and [BudJMT](https://steamcommunity.com/profiles/76561198067029619/myworkshopfiles/?appid=250900), the two smartest people in the Isaac community. Until 2022, it has been the engine that has powered all Isaac mods that have custom stages, like [Revelations](https://steamcommunity.com/sharedfiles/filedetails/?id=1536643474) and [Fiend Folio](https://steamcommunity.com/sharedfiles/filedetails/?id=2305131709&searchtext=fiend+folio). However, no library is perfect. I wanted to try and improve on Stage API with the following goals in mind:

<!--lint disable ordered-list-marker-value -->
<!--lint disable heading-increment -->

#### 1. An Isaac library should be dead-easy to use

- Creating a new stage should be as easy as specifying some values in a config file and then calling `spawnCustomTrapdoor`.
- Everything complicated should be abstracted away, with the ability to customize if needed.
- Auto-complete on functions and methods should work automatically. Just start typing.

#### 2. An Isaac library should be safe

- Creating stages can get complicated. You should immediately know if you are using a function incorrectly. You should never be running around in-game, troubleshooting run-time errors.
- It should be impossible to push broken code to production.

#### 3. An Isaac library should work without being a Workshop dependency

- When a user wants to play a mod, they should only have to subscribe to one thing on the Steam Workshop. Forcing the end-user to subscribe to multiple things is painful, complex, and unnecessary.
- Having stage logic bundled with the mod preserves backwards compatibility and ensures that stage logic is tightly-coupled to the mod logic that is using it.
- Having stage logic bundled with the mod allows the mod author to be in complete control of when they update to the latest version, if ever. This also allows the upstream library to make breaking changes and stay clean without having to worry about having perpetual technical debt (like Stage API).

#### 4. An Isaac library should use real XML/STB files

- StageAPI forces people to convert their XML files to something called "Lua rooms", which is XML data converted to Lua. It then imports the Lua rooms at run-time and manually deploys their contents.
- Lua rooms are, in essence, the biggest hack in the history of Isaac modding. A lot of code is dedicated to making it all work. (You have to architect a solution for loading empty room data, work around grid entities not spawning properly, handle special entities like Slides, and so on.)
- But what if there was a better way? There's no need to go down this rabbit hole. The IsaacScript library uses real XML/STB files, and lazy-loads their data when needed using the `goto` command, resulting in a completely seamless experience.
- This means that for people creating new stages, things are ultra simple - no Basement Renovator hooks required!

#### 5. An Isaac library should be compatible with other Isaac libraries

- No library should irreparably alter the base game. In other words, it should make no vanilla resource replacements. This is the same principle as [not importing for side effects](https://github.com/Zamiell/isaac-faq/blob/main/mod-organization.md#avoiding-side-effects).
- With no resource replacements, there's never a compatibility issue. Each mod can use their own library for their own stage.

#### 6. An Isaac library shouldn't cause lag on boot

- StageAPI loads data for hundreds of rooms on the first run, which causes lag.
- Libraries shouldn't do anything if they are not being used. This is the same principle as [not importing for side effects](https://github.com/Zamiell/isaac-faq/blob/main/mod-organization.md#avoiding-side-effects).
- Instead, by lazy loading data, IsaacScript custom stages only incur a tiny amount of lag when they are first traveled to. (Only the specific data needed for the actual generated floor is retrieved.)

#### 7. An Isaac library should have excellent documentation

- StageAPI has historically been undocumented. Recently, there have been some excellent documentation additions by Filloax (the person behind Revelations). With that said, all of the documentation is manually typed and prone to error.
- An old adage in programming is that [if it isn't documented, then it doesn't exist](https://blog.codinghorror.com/if-it-isnt-documented-it-doesnt-exist/). Beautiful, searchable, and easy-to-use documentation should be a first-class goal.
- Documentation should be automatically generated with tooling so that it never gets out of date.

<!--lint enable ordered-list-marker-value -->

With these improvements in mind, I've created the IsaacScript stage library. Since it is integrated into the normal [standard library](/isaacscript-common), using it is effortless. See the [getting started section](#getting-started) above.

<br />

## Custom Stage Room Variant Prefixes

Each custom stage needs a unique room variant prefix. And all of the room variant prefixes for each mod must not overlap with any other ones - otherwise, loading the custom stage will not work properly. In order to prevent conflicts, this section documents all of the arbitrary prefixes claimed by each mod. Valid prefixes are between 101 and 999, inclusive.

| Room Variant Prefix | Mod Name |
| ------------------- | -------- |
| n/a                 | n/a      |

(There are no mods yet that have claimed any prefixes. Click on the edit button below to add yours.)
